#pragma once

#if defined(ESP8266) || defined(ESP32)
#include <pgmspace.h>
#else
#include <avr/pgmspace.h>
#endif
#include <Arduino.h>
#include <Wire.h>

#define SSD1306_USE_UTF8 // Comment this define to use only ASCII chars
#define SSD1306_USE_SMALLFONT // Comment this define to use large (8x16) font

#ifdef ESP32
//#define SSD1306_USE_MUTEX
#endif

#ifdef SSD1306_USE_UTF8
typedef uint16_t utf8_t;
#endif
enum resolution_t : uint8_t { SSD1306_128x64, SSD1306_128x32, SSD1306_64x48, SSD1306_64x32 };

template<const resolution_t RESOLUTION, const uint8_t ADDR = 0, const int8_t RST_PIN = -1, TwoWire &WIRE = Wire>
class SSD1306 {
public:
#if defined(ESP32) && defined(SSD1306_USE_MUTEX)
  SSD1306() : _mutex(xSemaphoreCreateMutex()), _startPage(0), _negative(false) {}
  ~SSD1306() {
    if (_mutex)
      vSemaphoreDelete(_mutex);
  }
#else
  SSD1306() : _startPage(0), _negative(false) {}
#endif

#if defined(ESP8266) || defined(ESP32)
  static bool init(int8_t sda = -1, int8_t scl = -1, bool fast = true);
#else
  static bool init(bool fast = true);
#endif

  bool begin(bool reset = false);

  bool flip(bool on);
  bool invert(bool on);
  bool power(bool on);
  bool contrast(uint8_t value);
  uint8_t width() const;
  uint8_t height() const;

  bool clear();
  void negative(bool on) {
    _negative = on;
  }

  bool fillRect(uint8_t x, uint8_t y, uint8_t w, uint8_t h, bool color) {
    return drawPattern(x, y, w, h, (uint8_t)(color ? 0xFF : 0x00));
  }
  bool clearRect(uint8_t x, uint8_t y, uint8_t w, uint8_t h) {
    return drawPattern(x, y, w, h, (uint8_t)0x00);
  }

  bool drawPattern(uint8_t x, uint8_t y, uint8_t w, uint8_t h, uint8_t pattern, bool negative = false);
  bool drawPattern(uint8_t x, uint8_t y, uint8_t w, uint8_t h, const uint8_t *pattern, bool negative = false) {
    return _drawPattern(x, y, w, h, pattern, negative, false);
  }
  bool drawPattern_P(uint8_t x, uint8_t y, uint8_t w, uint8_t h, const uint8_t *pattern, bool negative = false) {
    return _drawPattern(x, y, w, h, pattern, negative, true);
  }

  bool drawXBM(uint8_t x, uint8_t y, uint8_t w, uint8_t h, const uint8_t *bitmap, bool negative = false) {
    return _drawXBM(x, y, w, h, bitmap, negative, false);
  }
  bool drawXBM_P(uint8_t x, uint8_t y, uint8_t w, uint8_t h, const uint8_t *bitmap, bool negative = false) {
    return _drawXBM(x, y, w, h, bitmap, negative, true);
  }

  uint8_t charWidth() const {
    return FONT_WIDTH * FONT_HSCALE + FONT_GAP;
  }
  uint8_t charHeight() const {
    return FONT_HEIGHT * FONT_VSCALE;
  }

#ifdef SSD1306_USE_UTF8
  bool printChar(uint8_t x, uint8_t y, utf8_t c);
#else
  bool printChar(uint8_t x, uint8_t y, uint8_t c);
#endif
  bool printStr(uint8_t x, uint8_t y, const char *str) {
    return _printStr(x, y, str, false);
  }
  bool printStr_P(uint8_t x, uint8_t y, const char *str) {
    return _printStr(x, y, str, true);
  }

protected:
#ifdef SSD1306_USE_SMALLFONT
  static const uint8_t FONT_WIDTH = 5;
  static const uint8_t FONT_HSCALE = 1;
  static const uint8_t FONT_HEIGHT = 8;
  static const uint8_t FONT_VSCALE = 1;
#else
  static const uint8_t FONT_WIDTH = 7;
  static const uint8_t FONT_HSCALE = 1;
  static const uint8_t FONT_HEIGHT = 8;
  static const uint8_t FONT_VSCALE = 2;
#endif
  static const uint8_t FONT_GAP = 1;

  void sendCommandStart();
  bool sendCommandEnd();
  bool sendCommand(uint8_t command);
  bool sendCommand(uint8_t command, uint8_t arg);
  bool sendCommand(uint8_t command, uint8_t arg1, uint8_t arg2);
  bool sendCommand(uint8_t command, uint8_t arg1, uint8_t arg2, uint8_t arg3);
  bool _sendCommand(const uint8_t *commands, uint8_t count, bool flash);
  bool sendCommand(const uint8_t *commands, uint8_t count) {
    return _sendCommand(commands, count, false);
  }
  bool sendCommand_P(const uint8_t *commands, uint8_t count) {
    return _sendCommand(commands, count, true);
  }

  void sendDataStart();
  bool sendDataEnd();
  bool sendData(uint8_t data, uint16_t count = 1, bool negative = false);
  bool _sendData(const uint8_t *data, uint16_t count, bool negative, bool flash);
  bool sendData(const uint8_t *data, uint16_t count, bool negative = false) {
    return _sendData(data, count, negative, false);
  }
  bool sendData_P(const uint8_t *data, uint16_t count, bool negative = false) {
    return _sendData(data, count, negative, true);
  }

  bool selectArea(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2);

#ifdef SSD1306_USE_UTF8
  const uint8_t *charPattern(utf8_t c);
#else
  const uint8_t *charPattern(uint8_t c);
#endif

  bool scroll(uint8_t pages);

  void transpBand(uint8_t *dest, const uint8_t *src, uint8_t w, uint8_t h, bool flash);

  bool _drawPattern(uint8_t x, uint8_t y, uint8_t w, uint8_t h, const uint8_t *pattern, bool negative, bool flash);
  bool _drawXBM(uint8_t x, uint8_t y, uint8_t w, uint8_t h, const uint8_t *bitmap, bool negative, bool flash);

  bool _printStr(uint8_t x, uint8_t y, const char *str, bool flash);

#if defined(ESP32) && defined(SSD1306_USE_MUTEX)
  void lock() {
    if (_mutex)
      xSemaphoreTake(_mutex, portMAX_DELAY);
  }
  void unlock() {
    if (_mutex)
      xSemaphoreGive(_mutex);
  }
#endif

#if defined(ESP32) && defined(SSD1306_USE_MUTEX)
  SemaphoreHandle_t _mutex;
#endif
  uint8_t _startPage : 3;
  bool _negative : 1;
};

#ifdef SSD1306_USE_SMALLFONT
static const uint8_t FONT_5X8[] PROGMEM = {
#ifdef SSD1306_USE_UTF8
  0x20, 0x00, 0x7E, 0x00, // From 0x0020 (' ') to 0x007E ('~')
#else
  0x20, 0x7E, // From 0x20 (' ') to 0x7E ('~')
#endif
  0x00, 0x00, 0x00, 0x00, 0x00, // ' '
  0x00, 0x00, 0x5F, 0x00, 0x00, // '!'
  0x00, 0x07, 0x00, 0x07, 0x00, // '"'
  0x14, 0x3E, 0x14, 0x3E, 0x14, // '#'
  0x24, 0x2A, 0x7F, 0x2A, 0x12, // '$'
  0x23, 0x13, 0x08, 0x64, 0x62, // '%'
  0x36, 0x49, 0x55, 0x22, 0x50, // '&'
  0x00, 0x04, 0x02, 0x01, 0x00, // '\''
  0x00, 0x1C, 0x22, 0x41, 0x00, // '('
  0x00, 0x41, 0x22, 0x1C, 0x00, // ')'
  0x14, 0x08, 0x3E, 0x08, 0x14, // '*'
  0x08, 0x08, 0x3E, 0x08, 0x08, // '+'
  0x00, 0xA0, 0x60, 0x00, 0x00, // ','
  0x08, 0x08, 0x08, 0x08, 0x08, // '-'
  0x00, 0x60, 0x60, 0x00, 0x00, // '.'
  0x20, 0x10, 0x08, 0x04, 0x02, // '/'
  0x3E, 0x51, 0x49, 0x45, 0x3E, // '0'
  0x04, 0x42, 0x7F, 0x40, 0x00, // '1'
  0x62, 0x51, 0x49, 0x49, 0x46, // '2'
  0x22, 0x41, 0x49, 0x49, 0x36, // '3'
  0x18, 0x14, 0x12, 0x7F, 0x10, // '4'
  0x27, 0x45, 0x45, 0x45, 0x39, // '5'
  0x3C, 0x4A, 0x49, 0x49, 0x30, // '6'
  0x01, 0x71, 0x09, 0x05, 0x03, // '7'
  0x36, 0x49, 0x49, 0x49, 0x36, // '8'
  0x06, 0x49, 0x49, 0x29, 0x1E, // '9'
  0x00, 0x36, 0x36, 0x00, 0x00, // ':'
  0x00, 0x56, 0x36, 0x00, 0x00, // ';'
  0x08, 0x14, 0x22, 0x41, 0x00, // '<'
  0x14, 0x14, 0x14, 0x14, 0x14, // '='
  0x41, 0x22, 0x14, 0x08, 0x00, // '>'
  0x02, 0x01, 0x51, 0x09, 0x06, // '?'
  0x32, 0x49, 0x79, 0x41, 0x3E, // '@'
  0x7C, 0x12, 0x11, 0x12, 0x7C, // 'A'
  0x41, 0x7F, 0x49, 0x49, 0x36, // 'B'
  0x3E, 0x41, 0x41, 0x41, 0x22, // 'C'
  0x41, 0x7F, 0x41, 0x41, 0x3E, // 'D'
  0x7F, 0x49, 0x49, 0x49, 0x41, // 'E'
  0x7F, 0x09, 0x09, 0x09, 0x01, // 'F'
  0x3E, 0x41, 0x41, 0x51, 0x72, // 'G'
  0x7F, 0x08, 0x08, 0x08, 0x7F, // 'H'
  0x00, 0x41, 0x7F, 0x41, 0x00, // 'I'
  0x20, 0x40, 0x41, 0x3F, 0x01, // 'J'
  0x7F, 0x08, 0x14, 0x22, 0x41, // 'K'
  0x7F, 0x40, 0x40, 0x40, 0x40, // 'L'
  0x7F, 0x02, 0x0C, 0x02, 0x7F, // 'M'
  0x7F, 0x04, 0x08, 0x10, 0x7F, // 'N'
  0x3E, 0x41, 0x41, 0x41, 0x3E, // 'O'
  0x7F, 0x09, 0x09, 0x09, 0x06, // 'P'
  0x3E, 0x41, 0x51, 0x21, 0x5E, // 'Q'
  0x7F, 0x09, 0x19, 0x29, 0x46, // 'R'
  0x26, 0x49, 0x49, 0x49, 0x32, // 'S'
  0x01, 0x01, 0x7F, 0x01, 0x01, // 'T'
  0x3F, 0x40, 0x40, 0x40, 0x3F, // 'U'
  0x1F, 0x20, 0x40, 0x20, 0x1F, // 'V'
  0x3F, 0x40, 0x38, 0x40, 0x3F, // 'W'
  0x63, 0x14, 0x08, 0x14, 0x63, // 'X'
  0x07, 0x08, 0x70, 0x08, 0x07, // 'Y'
  0x61, 0x51, 0x49, 0x45, 0x43, // 'Z'
  0x00, 0x7F, 0x41, 0x41, 0x00, // '['
  0x02, 0x04, 0x08, 0x10, 0x20, // '\\'
  0x00, 0x41, 0x41, 0x7F, 0x00, // ']'
  0x04, 0x02, 0x01, 0x02, 0x04, // '^'
  0x80, 0x80, 0x80, 0x80, 0x80, // '_'
  0x00, 0x01, 0x02, 0x04, 0x00, // '`'
  0x20, 0x54, 0x54, 0x54, 0x78, // 'a'
  0x7F, 0x48, 0x44, 0x44, 0x38, // 'b'
  0x38, 0x44, 0x44, 0x44, 0x20, // 'c'
  0x38, 0x44, 0x44, 0x48, 0x7F, // 'd'
  0x38, 0x54, 0x54, 0x54, 0x18, // 'e'
  0x08, 0x7E, 0x09, 0x01, 0x02, // 'f'
  0x18, 0xA4, 0xA4, 0xA4, 0x7C, // 'g'
  0x7F, 0x08, 0x04, 0x04, 0x78, // 'h'
  0x00, 0x48, 0x7D, 0x40, 0x00, // 'i'
  0x20, 0x40, 0x44, 0x3D, 0x00, // 'j'
  0x7F, 0x10, 0x28, 0x44, 0x00, // 'k'
  0x00, 0x41, 0x7F, 0x40, 0x00, // 'l'
  0x7C, 0x04, 0x78, 0x04, 0x78, // 'm'
  0x7C, 0x08, 0x04, 0x04, 0x78, // 'n'
  0x38, 0x44, 0x44, 0x44, 0x38, // 'o'
  0xFC, 0x24, 0x24, 0x24, 0x18, // 'p'
  0x18, 0x24, 0x24, 0x28, 0xFC, // 'q'
  0x7C, 0x08, 0x04, 0x04, 0x08, // 'r'
  0x48, 0x54, 0x54, 0x54, 0x20, // 's'
  0x04, 0x3F, 0x44, 0x40, 0x20, // 't'
  0x3C, 0x40, 0x40, 0x20, 0x7C, // 'u'
  0x1C, 0x20, 0x40, 0x20, 0x1C, // 'v'
  0x3C, 0x40, 0x30, 0x40, 0x3C, // 'w'
  0x44, 0x28, 0x10, 0x28, 0x44, // 'x'
  0x1C, 0xA0, 0xA0, 0x90, 0x7C, // 'y'
  0x44, 0x64, 0x54, 0x4C, 0x44, // 'z'
  0x00, 0x08, 0x36, 0x41, 0x00, // '{'
  0x00, 0x00, 0x7F, 0x00, 0x00, // '|'
  0x00, 0x41, 0x36, 0x08, 0x00, // '}'
  0x08, 0x04, 0x04, 0x08, 0x04, // '~'
#ifdef SSD1306_USE_UTF8
  0x01, 0x04, 0x01, 0x04, // From 0x0401 ('Ё') to 0x0401 ('Ё')
  0x7C, 0x55, 0x54, 0x55, 0x44, // 'Ё'
  0x10, 0x04, 0x4F, 0x04, // From 0x0410 ('А') to 0x044F ('я')
  0x7E, 0x11, 0x11, 0x11, 0x7E, // 'А'
  0x7F, 0x49, 0x49, 0x49, 0x33, // 'Б'
  0x7F, 0x49, 0x49, 0x49, 0x36, // 'В'
  0x7F, 0x01, 0x01, 0x01, 0x03, // 'Г'
  0x70, 0x29, 0x27, 0x21, 0x7F, // 'Д'
  0x7F, 0x49, 0x49, 0x49, 0x41, // 'Е'
  0x77, 0x08, 0x7F, 0x08, 0x77, // 'Ж'
  0x41, 0x41, 0x49, 0x49, 0x36, // 'З'
  0x7F, 0x10, 0x08, 0x04, 0x7F, // 'И'
  0x7C, 0x21, 0x12, 0x09, 0x7C, // 'Й'
  0x7F, 0x08, 0x14, 0x22, 0x41, // 'К'
  0x20, 0x41, 0x3F, 0x01, 0x7F, // 'Л'
  0x7F, 0x02, 0x0C, 0x02, 0x7F, // 'М'
  0x7F, 0x08, 0x08, 0x08, 0x7F, // 'Н'
  0x3E, 0x41, 0x41, 0x41, 0x3E, // 'О'
  0x7F, 0x01, 0x01, 0x01, 0x7F, // 'П'
  0x7F, 0x09, 0x09, 0x09, 0x06, // 'Р'
  0x3E, 0x41, 0x41, 0x41, 0x22, // 'С'
  0x01, 0x01, 0x7F, 0x01, 0x01, // 'Т'
  0x47, 0x28, 0x10, 0x08, 0x07, // 'У'
  0x1C, 0x22, 0x7F, 0x22, 0x1C, // 'Ф'
  0x63, 0x14, 0x08, 0x14, 0x63, // 'Х'
  0x7F, 0x40, 0x40, 0x7F, 0xC0, // 'Ц'
  0x07, 0x08, 0x08, 0x08, 0x7F, // 'Ч'
  0x7F, 0x40, 0x7F, 0x40, 0x7F, // 'Ш'
  0x7F, 0x40, 0x7F, 0x40, 0xFF, // 'Щ'
  0x01, 0x7F, 0x48, 0x48, 0x30, // 'Ъ'
  0x7F, 0x48, 0x30, 0x00, 0x7F, // 'Ы'
  0x7F, 0x48, 0x48, 0x48, 0x30, // 'Ь'
  0x22, 0x49, 0x45, 0x49, 0x3E, // 'Э'
  0x7F, 0x08, 0x3E, 0x41, 0x3E, // 'Ю'
  0x46, 0x29, 0x19, 0x09, 0x7F, // 'Я'
  0x20, 0x54, 0x54, 0x54, 0x78, // 'а'
  0x3C, 0x4A, 0x49, 0x49, 0x31, // 'б'
  0x7C, 0x54, 0x54, 0x54, 0x28, // 'в'
  0x7C, 0x04, 0x04, 0x04, 0x04, // 'г'
  0x60, 0x38, 0x24, 0x24, 0x7C, // 'д'
  0x38, 0x54, 0x54, 0x54, 0x18, // 'е'
  0x6C, 0x10, 0x7C, 0x10, 0x6C, // 'ж'
  0x44, 0x54, 0x54, 0x54, 0x28, // 'з'
  0x7C, 0x20, 0x10, 0x08, 0x7C, // 'и'
  0x78, 0x42, 0x24, 0x12, 0x78, // 'й'
  0x7C, 0x10, 0x28, 0x44, 0x00, // 'к'
  0x40, 0x3C, 0x04, 0x04, 0x7C, // 'л'
  0x7C, 0x08, 0x10, 0x08, 0x7C, // 'м'
  0x7C, 0x10, 0x10, 0x10, 0x7C, // 'н'
  0x38, 0x44, 0x44, 0x44, 0x38, // 'о'
  0x7C, 0x04, 0x04, 0x04, 0x7C, // 'п'
  0xFC, 0x24, 0x24, 0x24, 0x18, // 'р'
  0x38, 0x44, 0x44, 0x44, 0x20, // 'с'
  0x04, 0x04, 0x7C, 0x04, 0x04, // 'т'
  0x44, 0x28, 0x10, 0x08, 0x04, // 'у'
  0x18, 0x24, 0xFE, 0x24, 0x18, // 'ф'
  0x44, 0x28, 0x10, 0x28, 0x44, // 'х'
  0x7C, 0x40, 0x40, 0x7C, 0xC0, // 'ц'
  0x0C, 0x10, 0x10, 0x10, 0x7C, // 'ч'
  0x7C, 0x40, 0x7C, 0x40, 0x7C, // 'ш'
  0x7C, 0x40, 0x7C, 0x40, 0xFC, // 'щ'
  0x04, 0x7C, 0x50, 0x50, 0x20, // 'ъ'
  0x7C, 0x50, 0x20, 0x00, 0x7C, // 'ы'
  0x7C, 0x50, 0x50, 0x50, 0x20, // 'ь'
  0x44, 0x54, 0x54, 0x54, 0x38, // 'э'
  0x7C, 0x10, 0x38, 0x44, 0x38, // 'ю'
  0x48, 0x54, 0x34, 0x14, 0x7C, // 'я'
  0x51, 0x04, 0x51, 0x04, // From 0x0451 ('ё') to 0x0451 ('ё')
  0x38, 0x55, 0x54, 0x55, 0x18, // 'ё'
#endif
};
#else
static const uint8_t FONT_7X8[] PROGMEM = {
#ifdef SSD1306_USE_UTF8
  0x20, 0x00, 0x7E, 0x00, // From 0x0020 (' ') to 0x007E ('~')
#else
  0x20, 0x7E, // From 0x20 (' ') to 0x7E ('~')
#endif
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ' '
  0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, // '!'
  0x00, 0x07, 0x00, 0x00, 0x07, 0x00, 0x00, // '"'
  0x14, 0x7F, 0x14, 0x14, 0x7F, 0x14, 0x00, // '#'
  0x24, 0x2A, 0x2A, 0x7F, 0x2A, 0x2A, 0x12, // '$'
  0x43, 0x23, 0x10, 0x08, 0x04, 0x62, 0x61, // '%'
  0x36, 0x49, 0x49, 0x49, 0x56, 0x20, 0x50, // '&'
  0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, // '\''
  0x00, 0x00, 0x1C, 0x22, 0x41, 0x00, 0x00, // '('
  0x00, 0x00, 0x41, 0x22, 0x1C, 0x00, 0x00, // ')'
  0x22, 0x14, 0x08, 0x7F, 0x08, 0x14, 0x22, // '*'
  0x08, 0x08, 0x08, 0x3E, 0x08, 0x08, 0x08, // '+'
  0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x00, // ','
  0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, // '-'
  0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // '.'
  0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, // '/'
  0x3E, 0x61, 0x51, 0x49, 0x45, 0x43, 0x3E, // '0'
  0x00, 0x00, 0x42, 0x7F, 0x40, 0x00, 0x00, // '1'
  0x62, 0x51, 0x49, 0x49, 0x49, 0x49, 0x46, // '2'
  0x22, 0x41, 0x49, 0x49, 0x49, 0x49, 0x36, // '3'
  0x10, 0x18, 0x14, 0x12, 0x7F, 0x10, 0x00, // '4'
  0x27, 0x45, 0x45, 0x45, 0x45, 0x45, 0x39, // '5'
  0x3C, 0x4A, 0x49, 0x49, 0x49, 0x49, 0x31, // '6'
  0x01, 0x01, 0x01, 0x71, 0x09, 0x05, 0x03, // '7'
  0x36, 0x49, 0x49, 0x49, 0x49, 0x49, 0x36, // '8'
  0x46, 0x49, 0x49, 0x49, 0x49, 0x29, 0x1E, // '9'
  0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, // ':'
  0x00, 0x00, 0x80, 0x44, 0x00, 0x00, 0x00, // ';'
  0x00, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00, // '<'
  0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, // '='
  0x00, 0x41, 0x22, 0x14, 0x08, 0x00, 0x00, // '>'
  0x02, 0x01, 0x01, 0x51, 0x09, 0x05, 0x02, // '?'
  0x3E, 0x41, 0x49, 0x55, 0x55, 0x59, 0x4E, // '@'
  0x7C, 0x12, 0x11, 0x11, 0x11, 0x12, 0x7C, // 'A'
  0x7F, 0x49, 0x49, 0x49, 0x49, 0x49, 0x36, // 'B'
  0x3E, 0x41, 0x41, 0x41, 0x41, 0x41, 0x22, // 'C'
  0x7F, 0x41, 0x41, 0x41, 0x41, 0x41, 0x3E, // 'D'
  0x7F, 0x49, 0x49, 0x49, 0x49, 0x49, 0x41, // 'E'
  0x7F, 0x09, 0x09, 0x09, 0x09, 0x09, 0x01, // 'F'
  0x3E, 0x41, 0x41, 0x41, 0x51, 0x51, 0x71, // 'G'
  0x7F, 0x08, 0x08, 0x08, 0x08, 0x08, 0x7F, // 'H'
  0x00, 0x00, 0x41, 0x7F, 0x41, 0x00, 0x00, // 'I'
  0x20, 0x40, 0x40, 0x40, 0x40, 0x40, 0x3F, // 'J'
  0x7F, 0x08, 0x08, 0x08, 0x14, 0x22, 0x41, // 'K'
  0x7F, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, // 'L'
  0x7F, 0x02, 0x04, 0x08, 0x04, 0x02, 0x7F, // 'M'
  0x7F, 0x02, 0x04, 0x08, 0x10, 0x20, 0x7F, // 'N'
  0x3E, 0x41, 0x41, 0x41, 0x41, 0x41, 0x3E, // 'O'
  0x7F, 0x09, 0x09, 0x09, 0x09, 0x09, 0x06, // 'P'
  0x3E, 0x41, 0x41, 0x41, 0x51, 0x21, 0x5E, // 'Q'
  0x7F, 0x09, 0x09, 0x09, 0x19, 0x29, 0x46, // 'R'
  0x26, 0x49, 0x49, 0x49, 0x49, 0x49, 0x32, // 'S'
  0x01, 0x01, 0x01, 0x7F, 0x01, 0x01, 0x01, // 'T'
  0x3F, 0x40, 0x40, 0x40, 0x40, 0x40, 0x3F, // 'U'
  0x0F, 0x10, 0x20, 0x40, 0x20, 0x10, 0x0F, // 'V'
  0x7F, 0x20, 0x10, 0x0C, 0x10, 0x20, 0x7F, // 'W'
  0x63, 0x14, 0x08, 0x08, 0x08, 0x14, 0x63, // 'X'
  0x03, 0x04, 0x08, 0x70, 0x08, 0x04, 0x03, // 'Y'
  0x61, 0x51, 0x49, 0x49, 0x49, 0x45, 0x43, // 'Z'
  0x00, 0x7F, 0x41, 0x41, 0x41, 0x41, 0x00, // '['
  0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, // '\\'
  0x00, 0x41, 0x41, 0x41, 0x41, 0x7F, 0x00, // ']'
  0x00, 0x04, 0x02, 0x01, 0x02, 0x04, 0x00, // '^'
  0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, // '_'
  0x00, 0x00, 0x01, 0x02, 0x04, 0x00, 0x00, // '`'
  0x20, 0x54, 0x54, 0x54, 0x54, 0x54, 0x78, // 'a'
  0x7F, 0x44, 0x44, 0x44, 0x44, 0x44, 0x38, // 'b'
  0x38, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, // 'c'
  0x38, 0x44, 0x44, 0x44, 0x44, 0x44, 0x7F, // 'd'
  0x38, 0x54, 0x54, 0x54, 0x54, 0x54, 0x58, // 'e'
  0x08, 0x7E, 0x09, 0x09, 0x09, 0x09, 0x02, // 'f'
  0x18, 0xA4, 0xA4, 0xA4, 0xA4, 0xA4, 0x78, // 'g'
  0x7F, 0x04, 0x04, 0x04, 0x04, 0x04, 0x78, // 'h'
  0x00, 0x00, 0x44, 0x7D, 0x40, 0x00, 0x00, // 'i'
  0x40, 0x80, 0x80, 0x84, 0x84, 0x84, 0x7D, // 'j'
  0x7F, 0x10, 0x10, 0x10, 0x28, 0x44, 0x00, // 'k'
  0x00, 0x00, 0x41, 0x7F, 0x40, 0x00, 0x00, // 'l'
  0x7C, 0x04, 0x04, 0x78, 0x04, 0x04, 0x78, // 'm'
  0x7C, 0x04, 0x04, 0x04, 0x04, 0x04, 0x78, // 'n'
  0x38, 0x44, 0x44, 0x44, 0x44, 0x44, 0x38, // 'o'
  0xFC, 0x24, 0x24, 0x24, 0x24, 0x24, 0x18, // 'p'
  0x18, 0x24, 0x24, 0x24, 0x24, 0x24, 0xFC, // 'q'
  0x7C, 0x08, 0x04, 0x04, 0x04, 0x04, 0x04, // 'r'
  0x48, 0x54, 0x54, 0x54, 0x54, 0x54, 0x24, // 's'
  0x00, 0x04, 0x04, 0x3F, 0x44, 0x44, 0x20, // 't'
  0x3C, 0x40, 0x40, 0x40, 0x40, 0x20, 0x7C, // 'u'
  0x1C, 0x20, 0x40, 0x40, 0x40, 0x20, 0x1C, // 'v'
  0x7C, 0x40, 0x20, 0x10, 0x20, 0x40, 0x7C, // 'w'
  0x44, 0x28, 0x10, 0x10, 0x10, 0x28, 0x44, // 'x'
  0x1C, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0x7C, // 'y'
  0x44, 0x64, 0x54, 0x54, 0x54, 0x4C, 0x44, // 'z'
  0x00, 0x08, 0x08, 0x36, 0x41, 0x41, 0x00, // '{'
  0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, // '|'
  0x00, 0x41, 0x41, 0x36, 0x08, 0x08, 0x00, // '}'
  0x00, 0x18, 0x04, 0x08, 0x10, 0x0C, 0x00, // '~'
#ifdef SSD1306_USE_UTF8
  0x01, 0x04, 0x01, 0x04, // From 0x0401 ('Ё') to 0x0401 ('Ё')
  0x7C, 0x55, 0x54, 0x54, 0x54, 0x55, 0x44, // 'Ё'
  0x10, 0x04, 0x4F, 0x04, // From 0x0410 ('А') to 0x044F ('я')
  0x7C, 0x12, 0x11, 0x11, 0x11, 0x11, 0x7F, // 'А'
  0x7F, 0x49, 0x49, 0x49, 0x49, 0x49, 0x31, // 'Б'
  0x7F, 0x49, 0x49, 0x49, 0x49, 0x49, 0x36, // 'В'
  0x7F, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, // 'Г'
  0x60, 0x31, 0x2F, 0x21, 0x21, 0x3F, 0x60, // 'Д'
  0x7F, 0x49, 0x49, 0x49, 0x49, 0x49, 0x41, // 'Е'
  0x63, 0x14, 0x08, 0x7F, 0x08, 0x14, 0x63, // 'Ж'
  0x22, 0x41, 0x41, 0x49, 0x49, 0x49, 0x36, // 'З'
  0x7F, 0x20, 0x10, 0x08, 0x04, 0x02, 0x7F, // 'И'
  0x7C, 0x40, 0x21, 0x12, 0x09, 0x04, 0x7C, // 'Й'
  0x7F, 0x08, 0x08, 0x14, 0x22, 0x41, 0x00, // 'К'
  0x20, 0x41, 0x3F, 0x01, 0x01, 0x01, 0x7F, // 'Л'
  0x7F, 0x02, 0x04, 0x08, 0x04, 0x02, 0x7F, // 'М'
  0x7F, 0x08, 0x08, 0x08, 0x08, 0x08, 0x7F, // 'Н'
  0x3E, 0x41, 0x41, 0x41, 0x41, 0x41, 0x3E, // 'О'
  0x7F, 0x01, 0x01, 0x01, 0x01, 0x01, 0x7F, // 'П'
  0x7F, 0x09, 0x09, 0x09, 0x09, 0x09, 0x06, // 'Р'
  0x3E, 0x41, 0x41, 0x41, 0x41, 0x41, 0x22, // 'С'
  0x01, 0x01, 0x01, 0x7F, 0x01, 0x01, 0x01, // 'Т'
  0x43, 0x44, 0x28, 0x10, 0x08, 0x04, 0x03, // 'У'
  0x0C, 0x12, 0x12, 0x7F, 0x12, 0x12, 0x0C, // 'Ф'
  0x41, 0x22, 0x14, 0x08, 0x14, 0x22, 0x41, // 'Х'
  0x7F, 0x40, 0x40, 0x40, 0x40, 0x7F, 0xC0, // 'Ц'
  0x07, 0x08, 0x08, 0x08, 0x08, 0x08, 0x7F, // 'Ч'
  0x7F, 0x40, 0x40, 0x7F, 0x40, 0x40, 0x7F, // 'Ш'
  0x7F, 0x40, 0x40, 0x7F, 0x40, 0x40, 0xFF, // 'Щ'
  0x01, 0x01, 0x7F, 0x48, 0x48, 0x48, 0x30, // 'Ъ'
  0x7F, 0x48, 0x48, 0x48, 0x30, 0x00, 0x7F, // 'Ы'
  0x7F, 0x48, 0x48, 0x48, 0x48, 0x48, 0x30, // 'Ь'
  0x22, 0x41, 0x49, 0x49, 0x49, 0x49, 0x3E, // 'Э'
  0x7F, 0x08, 0x3E, 0x41, 0x41, 0x41, 0x3E, // 'Ю'
  0x46, 0x49, 0x29, 0x19, 0x09, 0x09, 0x7F, // 'Я'
  0x20, 0x54, 0x54, 0x54, 0x54, 0x54, 0x78, // 'а'
  0x38, 0x4C, 0x4A, 0x49, 0x49, 0x49, 0x31, // 'б'
  0x7C, 0x54, 0x54, 0x54, 0x54, 0x54, 0x28, // 'в'
  0x7C, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, // 'г'
  0x60, 0x30, 0x28, 0x24, 0x24, 0x3C, 0x60, // 'д'
  0x38, 0x54, 0x54, 0x54, 0x54, 0x54, 0x18, // 'е'
  0x44, 0x28, 0x10, 0x7C, 0x10, 0x28, 0x44, // 'ж'
  0x44, 0x44, 0x54, 0x54, 0x54, 0x54, 0x28, // 'з'
  0x7C, 0x40, 0x20, 0x10, 0x08, 0x04, 0x7C, // 'и'
  0x7C, 0x40, 0x21, 0x12, 0x09, 0x04, 0x7C, // 'й'
  0x7C, 0x10, 0x10, 0x10, 0x28, 0x44, 0x00, // 'к'
  0x40, 0x38, 0x04, 0x04, 0x04, 0x04, 0x7C, // 'л'
  0x7C, 0x08, 0x10, 0x20, 0x10, 0x08, 0x7C, // 'м'
  0x7C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7C, // 'н'
  0x38, 0x44, 0x44, 0x44, 0x44, 0x44, 0x38, // 'о'
  0x7C, 0x04, 0x04, 0x04, 0x04, 0x04, 0x7C, // 'п'
  0xFC, 0x24, 0x24, 0x24, 0x24, 0x24, 0x18, // 'р'
  0x38, 0x44, 0x44, 0x44, 0x44, 0x44, 0x20, // 'с'
  0x04, 0x04, 0x04, 0x7C, 0x04, 0x04, 0x04, // 'т'
  0x04, 0x48, 0x50, 0x20, 0x10, 0x08, 0x04, // 'у'
  0x18, 0x24, 0x24, 0xFE, 0x24, 0x24, 0x18, // 'ф'
  0x44, 0x28, 0x10, 0x10, 0x10, 0x28, 0x44, // 'х'
  0x7C, 0x40, 0x40, 0x40, 0x40, 0x7C, 0xC0, // 'ц'
  0x0C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7C, // 'ч'
  0x7C, 0x40, 0x40, 0x7C, 0x40, 0x40, 0x7C, // 'ш'
  0x7C, 0x40, 0x40, 0x7C, 0x40, 0x40, 0xFC, // 'щ'
  0x04, 0x04, 0x7C, 0x50, 0x50, 0x50, 0x20, // 'ъ'
  0x7C, 0x50, 0x50, 0x50, 0x20, 0x00, 0x7C, // 'ы'
  0x7C, 0x50, 0x50, 0x50, 0x50, 0x50, 0x20, // 'ь'
  0x44, 0x54, 0x54, 0x54, 0x54, 0x54, 0x38, // 'э'
  0x7C, 0x10, 0x38, 0x44, 0x44, 0x44, 0x38, // 'ю'
  0x48, 0x54, 0x34, 0x14, 0x14, 0x14, 0x7C, // 'я'
  0x51, 0x04, 0x51, 0x04, // From 0x0451 ('ё') to 0x0451 ('ё')
  0x38, 0x55, 0x54, 0x54, 0x54, 0x55, 0x58, // 'ё'
#endif
};
#endif

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
#if defined(ESP8266) || defined(ESP32)
bool SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::init(int8_t sda, int8_t scl, bool fast) {
#else
bool SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::init(bool fast) {
#endif
  if (RST_PIN >= 0) {
    pinMode(RST_PIN, OUTPUT);
    digitalWrite(RST_PIN, LOW);
    delay(10);
    digitalWrite(RST_PIN, HIGH);
  }
#if defined(ESP8266)
  if ((sda < 0) || (scl < 0))
    WIRE.begin();
  else
    WIRE.begin(sda, scl);
  if (fast)
    WIRE.setClock(400000);
  return true;
#elif defined(ESP32)
  return WIRE.begin(sda, scl, fast ? 400000 : 100000);
#else
  WIRE.begin();
  if (fast)
    WIRE.setClock(400000);
  return true;
#endif
}

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
bool SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::begin(bool reset) {
  if (reset && (RST_PIN >= 0)) {
    pinMode(RST_PIN, OUTPUT);
    digitalWrite(RST_PIN, LOW);
    delay(10);
    digitalWrite(RST_PIN, HIGH);
  }
#if defined(ESP32) && defined(SSD1306_USE_MUTEX)
  lock();
#endif
  _startPage = 0;
  reset = sendCommand(0xAE) && // DISPLAYOFF
    sendCommand(0xD5, 0x80) && // SETDISPLAYCLOCKDIV = 0x80
    sendCommand(0xA8, RESOLUTION == SSD1306_128x64 ? 0x3F : RESOLUTION == SSD1306_64x48 ? 0x2F : 0x1F) && // SETMULTIPLEX
    sendCommand(0xD3, 0x00) && // SETDISPLAYOFFSET = 0x00
    sendCommand(0x40 | 0) && // SETSTARTLINE (_startPage * 8)
    sendCommand(0x8D, 0x14) && // CHARGEPUMP = 0x14
    sendCommand(0xA0 | 0x01) && // SEGREMAP = reverse
    sendCommand(0xC8) && // COMSCANDEC
    sendCommand(0xDA, RESOLUTION == SSD1306_128x32 ? 0x02 : 0x12) && // SETCOMPINS
    sendCommand(0xD9, 0x22) && // SETPRECHARGE = 0x22
    sendCommand(0xDB, RESOLUTION == SSD1306_128x64 ? 0x40 : (RESOLUTION == SSD1306_128x32 ? 0x20 : 0x00)) && // SETVCOMDETECT
    sendCommand(0x20, 0x00) && // MEMORYMODE = HORIZONTAL_ADDRESSING_MODE
    sendCommand(0x81, RESOLUTION >= SSD1306_64x48 ? 0xCF : 0x7F) && // SETCONTRAST
    sendCommand(0xA4) && // DISPLAYALLON_RESUME
    sendCommand(0xA6) && // NORMALDISPLAY
    sendCommand(0xAF); // DISPLAYON
#if defined(ESP32) && defined(SSD1306_USE_MUTEX)
  unlock();
#endif
  return reset;
}

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
bool SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::flip(bool on) {
#if defined(ESP32) && defined(SSD1306_USE_MUTEX)
  lock();
#endif
  if (on) {
    on = sendCommand(0xA0) && // SEGREMAP = normal
      sendCommand(0xC0); // COMSCANINC
  } else {
    on = sendCommand(0xA0 | 0x01) && // SEGREMAP = reverse
      sendCommand(0xC8); // COMSCANDEC
  }
#if defined(ESP32) && defined(SSD1306_USE_MUTEX)
  unlock();
#endif
  return on;
}

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
bool SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::invert(bool on) {
#if defined(ESP32) && defined(SSD1306_USE_MUTEX)
  lock();
#endif
  on = sendCommand(0xA6 | on); // NORMALDISPLAY or INVERSEDISPLAY
#if defined(ESP32) && defined(SSD1306_USE_MUTEX)
  unlock();
#endif
  return on;
}

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
bool SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::power(bool on) {
#if defined(ESP32) && defined(SSD1306_USE_MUTEX)
  lock();
#endif
  on = sendCommand(0xAE | on);
#if defined(ESP32) && defined(SSD1306_USE_MUTEX)
  unlock();
#endif
  return on;
}

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
bool SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::contrast(uint8_t value) {
#if defined(ESP32) && defined(SSD1306_USE_MUTEX)
  lock();
#endif
  value = sendCommand(0x81, value);
#if defined(ESP32) && defined(SSD1306_USE_MUTEX)
  unlock();
#endif
  return value;
}

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
inline uint8_t SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::width() const {
  return RESOLUTION >= SSD1306_64x48 ? 64 : 128;
}

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
inline uint8_t SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::height() const {
  return RESOLUTION == SSD1306_128x64 ? 64 : RESOLUTION == SSD1306_64x48 ? 48 : 32;
}

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
bool SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::clear() {
  bool result;
  uint8_t w = width();
  uint8_t h = height();

#if defined(ESP32) && defined(SSD1306_USE_MUTEX)
  lock();
#endif
  _startPage = 0;
  result = sendCommand(0x40 | 0) && selectArea(0, 0, w - 1, h - 1) && sendData((uint8_t)0, w * (h / 8));
#if defined(ESP32) && defined(SSD1306_USE_MUTEX)
  unlock();
#endif
  return result;
}

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
bool SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::drawPattern(uint8_t x, uint8_t y, uint8_t w, uint8_t h, uint8_t pattern, bool negative) {
  uint8_t _w, _h;

  _w = width();
  _h = height();
  y = (y / 8) * 8;
  if ((x >= _w) || (y >= _h)) // Out of screen
    return false;
  if (x + w > _w)
    _w -= x;
  else
    _w = w;
  if (y + h > _h)
    _h -= y;
  else
    _h = h;
#if defined(ESP32) && defined(SSD1306_USE_MUTEX)
  lock();
#endif
  for (uint8_t _y = y; _y < y + _h; _y += 8) {
    if ((! selectArea(x, _y, x + _w - 1, _y + 7)) || (! sendData(pattern, _w, negative))) {
#if defined(ESP32) && defined(SSD1306_USE_MUTEX)
      unlock();
#endif
      return false;
    }
  }
#if defined(ESP32) && defined(SSD1306_USE_MUTEX)
  unlock();
#endif
  return true;
}

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
void SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::sendCommandStart() {
  WIRE.beginTransmission(ADDR ? ADDR : RESOLUTION == SSD1306_128x64 ? 0x3D : 0x3C);
  WIRE.write(0x00);
}

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
inline bool SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::sendCommandEnd() {
  return WIRE.endTransmission() == 0;
}

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
bool SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::sendCommand(uint8_t command) {
  sendCommandStart();
  WIRE.write(command);
  return sendCommandEnd();
}

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
bool SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::sendCommand(uint8_t command, uint8_t arg) {
  sendCommandStart();
  WIRE.write(command);
  WIRE.write(arg);
  return sendCommandEnd();
}

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
bool SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::sendCommand(uint8_t command, uint8_t arg1, uint8_t arg2) {
  sendCommandStart();
  WIRE.write(command);
  WIRE.write(arg1);
  WIRE.write(arg2);
  return sendCommandEnd();
}

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
bool SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::sendCommand(uint8_t command, uint8_t arg1, uint8_t arg2, uint8_t arg3) {
  sendCommandStart();
  WIRE.write(command);
  WIRE.write(arg1);
  WIRE.write(arg2);
  WIRE.write(arg3);
  return sendCommandEnd();
}

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
bool SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::_sendCommand(const uint8_t *commands, uint8_t count, bool flash) {
  sendCommandStart();
  while (count--) {
    uint8_t c;

    if (flash)
      c = pgm_read_byte(commands++);
    else
      c = *commands++;
    if (! WIRE.write(c)) {
      if (! sendCommandEnd())
        return false;
      sendCommandStart();
      WIRE.write(c);
    }
  }
  return sendCommandEnd();
}

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
void SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::sendDataStart() {
  WIRE.beginTransmission(ADDR ? ADDR : RESOLUTION == SSD1306_128x64 ? 0x3D : 0x3C);
  WIRE.write(0x40);
}

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
inline bool SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::sendDataEnd() {
  return WIRE.endTransmission() == 0;
}

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
bool SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::sendData(uint8_t data, uint16_t count, bool negative) {
  if (negative)
    data ^= 0xFF;
  sendDataStart();
  while (count--) {
    if (! WIRE.write(data)) {
      if (! sendDataEnd())
        return false;
      sendDataStart();
      WIRE.write(data);
    }
  }
  return sendDataEnd();
}

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
bool SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::_sendData(const uint8_t *data, uint16_t count, bool negative, bool flash) {
  sendDataStart();
  while (count--) {
    uint8_t d;

    if (flash)
      d = pgm_read_byte(data++);
    else
      d = *data++;
    if (negative)
      d ^= 0xFF;
    if (! WIRE.write(d)) {
      if (! sendDataEnd())
        return false;
      sendDataStart();
      WIRE.write(d);
    }
  }
  return sendDataEnd();
}

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
bool SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::selectArea(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2) {
  uint8_t offset;

  if (RESOLUTION >= SSD1306_64x48)
    offset = 0x20;
  else
    offset = 0;
  return sendCommand(0x21, x1 + offset, x2 + offset) && sendCommand(0x22, (y1 / 8 + _startPage) % 8, (y2 / 8 + _startPage) % 8);
}

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
#ifdef SSD1306_USE_UTF8
bool SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::printChar(uint8_t x, uint8_t y, utf8_t c) {
#else
bool SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::printChar(uint8_t x, uint8_t y, uint8_t c) {
#endif
  const uint8_t *pattern;
  bool result;

  pattern = charPattern(c);
  if (pattern) {
    if ((FONT_HSCALE == 1) && (FONT_VSCALE == 1)) {
      result = drawPattern_P(x, y, FONT_WIDTH, FONT_HEIGHT, pattern, _negative) &&
        drawPattern(x + FONT_WIDTH, y, FONT_GAP, FONT_HEIGHT, (uint8_t)0, _negative);
    } else {
      uint8_t _pattern[(FONT_WIDTH * FONT_HSCALE) * (((FONT_HEIGHT * FONT_VSCALE) + 7) / 8)];

      if (FONT_HSCALE > 1) { // Doubled horizontally
        for (uint8_t y = 0; y < (FONT_HEIGHT + 7) / 8; ++y) {
          for (uint8_t x = 0; x < FONT_WIDTH; ++x) {
            uint8_t d = pgm_read_byte(&pattern[y * FONT_WIDTH + x]);

            _pattern[y * (FONT_WIDTH * FONT_HSCALE) + x * 2] = d;
            _pattern[y * (FONT_WIDTH * FONT_HSCALE) + x * 2 + 1] = d;
          }
        }
      } else {
        memcpy_P(_pattern, pattern, FONT_WIDTH * ((FONT_HEIGHT + 7) / 8));
      }
      if (FONT_VSCALE > 1) { // Doubled vertically
        for (int8_t y = (FONT_HEIGHT + 7) / 8 - 1; y >= 0; --y) {
          for (uint8_t x = 0; x < FONT_WIDTH * FONT_HSCALE; ++x) {
            uint8_t d = _pattern[y * (FONT_WIDTH * FONT_HSCALE) + x];

            _pattern[y * (FONT_WIDTH * FONT_HSCALE) + x] = (d & 0x01) | ((d & 0x01) << 1) | ((d & 0x02) << 1) | ((d & 0x02) << 2) | ((d & 0x04) << 2) | ((d & 0x04) << 3) | ((d & 0x08) << 3) | ((d & 0x08) << 4);
            _pattern[(y + 1) * (FONT_WIDTH * FONT_HSCALE) + x] = ((d & 0x10) >> 4) | ((d & 0x10) >> 3) | ((d & 0x20) >> 3) | ((d & 0x20) >> 2) | ((d & 0x40) >> 2) | ((d & 0x40) >> 1) | ((d & 0x80) >> 1) | (d & 0x80);
          }
        }
      }
      result = drawPattern(x, y, FONT_WIDTH * FONT_HSCALE, FONT_HEIGHT * FONT_VSCALE, _pattern, _negative) &&
        drawPattern(x + FONT_WIDTH * FONT_HSCALE, y, FONT_GAP, FONT_HEIGHT * FONT_VSCALE, (uint8_t)0, _negative);
    }
  } else { // Char pattern not found
    result = drawPattern(x, y, FONT_WIDTH * FONT_HSCALE, FONT_HEIGHT * FONT_VSCALE, (uint8_t)0, _negative) &&
      drawPattern(x + FONT_WIDTH * FONT_HSCALE, y, FONT_GAP, FONT_HEIGHT * FONT_VSCALE, (uint8_t)0, _negative);
  }
  return result;
}

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
#ifdef SSD1306_USE_UTF8
const uint8_t *SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::charPattern(utf8_t c) {
#else
const uint8_t *SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::charPattern(uint8_t c) {
#endif
  uint16_t offset;
#ifdef SSD1306_USE_UTF8
  uint16_t from, to;
#else
  uint8_t from, to;
#endif

  offset = 0;
#ifdef SSD1306_USE_SMALLFONT
  from = pgm_read_byte(&FONT_5X8[offset++]);
#else
  from = pgm_read_byte(&FONT_7X8[offset++]);
#endif
#ifdef SSD1306_USE_UTF8
#ifdef SSD1306_USE_SMALLFONT
  from |= ((uint16_t)pgm_read_byte(&FONT_5X8[offset++]) << 8);
#else
  from |= ((uint16_t)pgm_read_byte(&FONT_7X8[offset++]) << 8);
#endif
#endif
#ifdef SSD1306_USE_SMALLFONT
  to = pgm_read_byte(&FONT_5X8[offset++]);
#else
  to = pgm_read_byte(&FONT_7X8[offset++]);
#endif
#ifdef SSD1306_USE_UTF8
#ifdef SSD1306_USE_SMALLFONT
  to |= ((uint16_t)pgm_read_byte(&FONT_5X8[offset++]) << 8);
#else
  to |= ((uint16_t)pgm_read_byte(&FONT_7X8[offset++]) << 8);
#endif
#endif
  while ((c < from) || (c > to)) {
    offset += ((to - from + 1) * (FONT_WIDTH * ((FONT_HEIGHT + 7) / 8)));
#ifdef SSD1306_USE_SMALLFONT
    if (offset >= sizeof(FONT_5X8))
#else
    if (offset >= sizeof(FONT_7X8))
#endif
      return nullptr;
#ifdef SSD1306_USE_SMALLFONT
    from = pgm_read_byte(&FONT_5X8[offset++]);
#else
    from = pgm_read_byte(&FONT_7X8[offset++]);
#endif
#ifdef SSD1306_USE_UTF8
#ifdef SSD1306_USE_SMALLFONT
    from |= ((uint16_t)pgm_read_byte(&FONT_5X8[offset++]) << 8);
#else
    from |= ((uint16_t)pgm_read_byte(&FONT_7X8[offset++]) << 8);
#endif
#endif
#ifdef SSD1306_USE_SMALLFONT
    to = pgm_read_byte(&FONT_5X8[offset++]);
#else
    to = pgm_read_byte(&FONT_7X8[offset++]);
#endif
#ifdef SSD1306_USE_UTF8
#ifdef SSD1306_USE_SMALLFONT
    to |= ((uint16_t)pgm_read_byte(&FONT_5X8[offset++]) << 8);
#else
    to |= ((uint16_t)pgm_read_byte(&FONT_7X8[offset++]) << 8);
#endif
#endif
  }
#ifdef SSD1306_USE_SMALLFONT
  return &FONT_5X8[offset + (c - from) * (FONT_WIDTH * ((FONT_HEIGHT + 7) / 8))];
#else
  return &FONT_7X8[offset + (c - from) * (FONT_WIDTH * ((FONT_HEIGHT + 7) / 8))];
#endif
}

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
bool SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::scroll(uint8_t pages) {
  bool result;
  uint8_t w = width();
  uint8_t h = height();

#if defined(ESP32) && defined(SSD1306_USE_MUTEX)
  lock();
#endif
  _startPage = (_startPage + pages) % 8;
  result = sendCommand(0x40 | (_startPage * 8)) && // SETSTARTLINE
    selectArea(0, h - pages * 8, w - 1, h - 1) && sendData((uint8_t)0, w * pages);
#if defined(ESP32) && defined(SSD1306_USE_MUTEX)
  unlock();
#endif
  return result;
}

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
void SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::transpBand(uint8_t *dest, const uint8_t *src, uint8_t w, uint8_t h, bool flash) {
  memset(dest, 0, w);
  for (uint8_t y = 0; y < h; ++y) {
    for (uint8_t x = 0; x < w; x += 8) {
      uint8_t data;

      if (flash)
        data = pgm_read_byte(&src[y * ((w + 7) / 8) + x / 8]);
      else
        data = src[y * ((w + 7) / 8) + x / 8];
      for (uint8_t _x = 0; (_x < 8) && (x + _x < w); ++_x) {
        dest[x + _x] |= (((data >> _x) & 0x01) << y);
      }
    }
  }
}

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
bool SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::_drawPattern(uint8_t x, uint8_t y, uint8_t w, uint8_t h, const uint8_t *pattern, bool negative, bool flash) {
  uint8_t _w, _h;

  _w = width();
  _h = height();
  y = (y / 8) * 8;
  if ((x >= _w) || (y >= _h)) // Out of screen
    return false;
  if (x + w > _w)
    _w -= x;
  else
    _w = w;
  if (y + h > _h)
    _h -= y;
  else
    _h = h;
#if defined(ESP32) && defined(SSD1306_USE_MUTEX)
  lock();
#endif
  for (uint8_t _y = y; _y < y + _h; _y += 8) {
    if ((! selectArea(x, _y, x + _w - 1, _y + 7)) || (! _sendData(&pattern[((_y - y) / 8) * w], _w, negative, flash))) {
#if defined(ESP32) && defined(SSD1306_USE_MUTEX)
      unlock();
#endif
      return false;
    }
  }
#if defined(ESP32) && defined(SSD1306_USE_MUTEX)
  unlock();
#endif
  return true;
}

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
bool SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::_drawXBM(uint8_t x, uint8_t y, uint8_t w, uint8_t h, const uint8_t *bitmap, bool negative, bool flash) {
  uint8_t _w, _h;

  _w = width();
  _h = height();
  y = (y / 8) * 8;
  if ((x >= _w) || (y >= _h)) // Out of screen
    return false;
  if (x + w > _w)
    _w -= x;
  else
    _w = w;
  if (y + h > _h)
    _h -= y;
  else
    _h = h;
#if defined(ESP32) && defined(SSD1306_USE_MUTEX)
  lock();
#endif
  for (uint8_t _y = y; _y < y + _h; _y += 8) {
    uint8_t _transp[_w];

    if (! selectArea(x, _y, x + _w - 1, _y + 7)) {
#if defined(ESP32) && defined(SSD1306_USE_MUTEX)
      unlock();
#endif
      return false;
    }
    transpBand(_transp, &bitmap[(_y - y) * ((w + 7) / 8)], _w, y + _h - _y >= 8 ? 8 : y + _h - _y, flash);
    if (! sendData(_transp, _w, negative)) {
#if defined(ESP32) && defined(SSD1306_USE_MUTEX)
      unlock();
#endif
      return false;
    }
  }
#if defined(ESP32) && defined(SSD1306_USE_MUTEX)
  unlock();
#endif
  return true;
}

template<const resolution_t RESOLUTION, const uint8_t ADDR, const int8_t RST_PIN, TwoWire &WIRE>
bool SSD1306<RESOLUTION, ADDR, RST_PIN, WIRE>::_printStr(uint8_t x, uint8_t y, const char *str, bool flash) {
  uint8_t b;

  if (flash)
    b = pgm_read_byte(str++);
  else
    b = *str++;
  while (b && (x < width())) {
#ifdef SSD1306_USE_UTF8
    utf8_t c = 0;

    if (b & 0x80) {
      if ((b & 0B11100000) == 0B11000000) {
        c = (uint16_t)(b & 0B00011111) << 6;
        if (flash)
          b = pgm_read_byte(str++);
        else
          b = *str++;
        if ((b & 0B11000000) == 0B10000000)
          c |= (b & 0B00111111);
        else
          return false;
      } else if ((b & 0B11110000) == 0B11100000) {
        c = (uint16_t)(b & 0B00001111) << 12;
        if (flash)
          b = pgm_read_byte(str++);
        else
          b = *str++;
        if ((b & 0B11000000) == 0B10000000) {
          c |= (uint16_t)(b & 0B00111111) << 6;
          if (flash)
            b = pgm_read_byte(str++);
          else
            b = *str++;
          if ((b & 0B11000000) == 0B10000000)
            c |= (b & 0B00111111);
          else
            return false;
        } else
          return false;
      }
    } else
      c = b;
    if (! printChar(x, y, c))
#else
    if (! printChar(x, y, b))
#endif
      return false;
    x += charWidth();
    if (flash)
      b = pgm_read_byte(str++);
    else
      b = *str++;
  }
  return true;
}
